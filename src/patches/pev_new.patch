diff --git a/CMakeLists.txt b/CMakeLists.txt
new file mode 100644
index 0000000..4fdc076
--- /dev/null
+++ b/CMakeLists.txt
@@ -0,0 +1,22 @@
+cmake_minimum_required(VERSION 3.9.0)
+project(pe_pev)
+set(CMAKE_VERBOSE_MAKEFILE ON)
+set(CMAKE_C_STANDARD 11)
+set(LIBPE_DIR lib/libpe)
+set(PEV_DIR src)
+
+
+include_directories(include)
+include_directories(include/compat)
+include_directories(include/compat/sys)
+include_directories(lib/libpe/include)
+include_directories(lib/libpe/include/libpe)
+include_directories(lib/libpe/libfuzzy)
+include_directories(lib/libpe/libudis86)
+include_directories(lib/libudis86)
+include_directories(lib/libudis86/libudis86)
+include_directories(src)
+add_subdirectory(${LIBPE_DIR})
+add_subdirectory(${PEV_DIR})
+add_library(pe_pev STATIC)
+target_link_libraries(pe_pev pe peversionlib)
diff --git a/src/CMakeLists.txt b/src/CMakeLists.txt
new file mode 100644
index 0000000..733988d
--- /dev/null
+++ b/src/CMakeLists.txt
@@ -0,0 +1,11 @@
+set(pev_Static_SRC
+        output.c
+        pev_api.c
+        utils.c
+        output_plugin.c
+        compat/strlcat.c
+        peres_lib.c
+        )
+add_library(peversionlib OBJECT ${pev_Static_SRC})
+target_compile_definitions(peversionlib PUBLIC OBJ)
+target_link_libraries(peversionlib pe)
diff --git a/src/peres_lib.c b/src/peres_lib.c
new file mode 100644
index 0000000..d543a2f
--- /dev/null
+++ b/src/peres_lib.c
@@ -0,0 +1,475 @@
+/*
+ * peres_lib.c
+ *
+ *  Created on: May 26, 2019
+ *      Author: root
+ */
+
+
+/*
+    pev - the PE file analyzer toolkit
+
+    peres.c - retrive informations and binary data of resources
+
+    Copyright (C) 2012 - 2017 pev authors
+
+    This program is free software: you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+    In addition, as a special exception, the copyright holders give
+    permission to link the code of portions of this program with the
+    OpenSSL library under certain conditions as described in each
+    individual source file, and distribute linked combinations
+    including the two.
+
+    You must obey the GNU General Public License in all respects
+    for all of the code used other than OpenSSL.  If you modify
+    file(s) with this exception, you may extend this exception to your
+    version of the file(s), but you are not obligated to do so.  If you
+    do not wish to do so, delete this exception statement from your
+    version.  If you delete this exception statement from all source
+    files in the program, then also delete it here.
+*/
+
+#include "common.h"
+#include <string.h>
+
+#define PROGRAM "peres"
+
+const char *resourceDir = "resources";
+
+#include "../lib/libudis86/udis86.h"
+#include <assert.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <unistd.h>
+
+
+
+
+static void freeNodes(NODE_PERES *currentNode)
+{
+    if (currentNode == NULL)
+        return;
+
+    while (currentNode->nextNode != NULL) {
+        currentNode = currentNode->nextNode;
+    }
+
+    while (currentNode != NULL) {
+        if (currentNode->lastNode == NULL) {
+            free(currentNode);
+            break;
+        } else {
+            currentNode = currentNode->lastNode;
+            if (currentNode->nextNode != NULL)
+                free(currentNode->nextNode);
+        }
+    }
+}
+
+static NODE_PERES * createNode(NODE_PERES *currentNode, NODE_TYPE_PERES typeOfNextNode)
+{
+    assert(currentNode != NULL);
+    NODE_PERES *newNode = malloc(sizeof(NODE_PERES));
+    newNode->lastNode = currentNode;
+    newNode->nextNode = NULL;
+    newNode->nodeType = typeOfNextNode;
+    currentNode->nextNode = newNode;
+    return newNode;
+}
+
+static const NODE_PERES * lastNodeByType(const NODE_PERES *currentNode, NODE_TYPE_PERES nodeTypeSearch)
+{
+    assert(currentNode != NULL);
+    if (currentNode->nodeType == nodeTypeSearch)
+        return currentNode;
+
+    while (currentNode != NULL) {
+        currentNode = currentNode->lastNode;
+        if (currentNode != NULL && currentNode->nodeType == nodeTypeSearch)
+            return currentNode;
+    }
+
+    return NULL;
+}
+
+/*
+static const NODE_PERES * firstNodeByType(const NODE_PERES *currentNode, NODE_TYPE_PERES nodeTypeSearch)
+{
+    assert(currentNode != NULL);
+    const NODE_PERES *firstNode = NULL;
+
+    if (currentNode->nodeType == nodeTypeSearch)
+        firstNode = currentNode;
+
+    while (currentNode != NULL) {
+        currentNode = currentNode->lastNode;
+        if (currentNode != NULL && currentNode->nodeType == nodeTypeSearch)
+            firstNode = currentNode;
+    }
+
+    return firstNode;
+}
+*/
+
+static const NODE_PERES * lastNodeByTypeAndLevel(const NODE_PERES *currentNode, NODE_TYPE_PERES nodeTypeSearch, NODE_LEVEL_PERES nodeLevelSearch)
+{
+    assert(currentNode != NULL);
+    if (currentNode->nodeType == nodeTypeSearch && currentNode->nodeLevel == nodeLevelSearch)
+        return currentNode;
+
+    while (currentNode != NULL) {
+        currentNode = currentNode->lastNode;
+        if (currentNode != NULL && currentNode->nodeType == nodeTypeSearch && currentNode->nodeLevel == nodeLevelSearch)
+            return currentNode;
+    }
+
+    return NULL;
+}
+
+
+
+static void getVersion(pe_ctx_t *ctx, const NODE_PERES *node,char *res)
+{
+    assert(node != NULL);
+
+    int count = 0;
+    const NODE_PERES *dataEntryNode;
+    uint32_t nameOffset;
+    bool found = false;
+
+    while (node->lastNode != NULL) {
+        node = node->lastNode;
+    }
+
+    while (node != NULL) {
+        if (node->nodeType != RDT_DATA_ENTRY) {
+            node = node->nextNode;
+            continue;
+        }
+        count++;
+        //if (count==19)
+        dataEntryNode = lastNodeByType(node, RDT_DATA_ENTRY);
+        if (dataEntryNode == NULL)
+            return;
+        nameOffset = node->rootNode->resource.directoryEntry->DirectoryName.name.NameOffset;
+        if (nameOffset == 16) {
+            found = true;
+            break;
+        }
+        node = node->nextNode;
+    }
+
+    if (!found)
+        return;
+
+    const uint64_t offsetData = pe_rva2ofs(ctx, dataEntryNode->resource.dataEntry->offsetToData);
+    const size_t dataEntrySize = dataEntryNode->resource.dataEntry->size;
+    const char *buffer = LIBPE_PTR_ADD(ctx->map_addr, 32 + offsetData);
+    if (!pe_can_read(ctx, buffer, dataEntrySize)) {
+        // TODO: Should we report something?
+        return;
+    }
+
+    VS_FIXEDFILEINFO *info = (VS_FIXEDFILEINFO *) buffer;
+    //char value[MAX_MSG];
+
+    //snprintf(value, MAX_MSG, "%d", totalCount);
+
+
+    snprintf(res, MAX_MSG, "%u.%u.%u.%u",
+    (unsigned int)(info->dwProductVersionMS & 0xffff0000) >> 16,
+    (unsigned int)info->dwProductVersionMS & 0x0000ffff,
+    (unsigned int)(info->dwProductVersionLS & 0xffff0000) >> 16,
+    (unsigned int)info->dwProductVersionLS & 0x0000ffff);
+
+    printf ("File Version %s", res);
+
+}
+
+static NODE_PERES * discoveryNodesPeres(pe_ctx_t *ctx)
+{
+#ifdef LIBPE_ENABLE_OUTPUT_COMPAT_WITH_V06
+    typedef struct {
+        ImageDirectoryEntry entry;
+        const char * const name;
+    } ImageDirectoryEntryName;
+    static const ImageDirectoryEntryName directoryEntryNames[] = {
+        { IMAGE_DIRECTORY_ENTRY_EXPORT,         "Export Table"              }, // "Export directory",
+        { IMAGE_DIRECTORY_ENTRY_IMPORT,         "Import Table"              }, // "Import directory",
+        { IMAGE_DIRECTORY_ENTRY_RESOURCE,       "Resource Table"            }, // "Resource directory",
+        { IMAGE_DIRECTORY_ENTRY_EXCEPTION,      "Exception Table"           }, // "Exception directory",
+        { IMAGE_DIRECTORY_ENTRY_SECURITY,       "Certificate Table"         }, // "Security directory",
+        { IMAGE_DIRECTORY_ENTRY_BASERELOC,      "Base Relocation Table"     }, // "Base relocation table",
+        { IMAGE_DIRECTORY_ENTRY_DEBUG,          "Debug"                     }, // "Debug directory",
+        { IMAGE_DIRECTORY_ENTRY_ARCHITECTURE,   "Architecture"              }, // "Architecture-specific data",
+        { IMAGE_DIRECTORY_ENTRY_GLOBALPTR,      "Global Ptr"                }, // "Global pointer",
+        { IMAGE_DIRECTORY_ENTRY_TLS,            "Thread Local Storage (TLS)"}, // "Thread local storage (TLS) directory",
+        { IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG,    "Load Config Table"         }, // "Load configuration directory",
+        { IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT,   "Bound Import"              }, // "Bound import directory",
+        { IMAGE_DIRECTORY_ENTRY_IAT,            "Import Address Table (IAT)"}, // "Import address table (IAT)",
+        { IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT,   "Delay Import Descriptor"   }, // "Delay import table",
+        { IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR, "CLR Runtime Header"        }, // "COM descriptor table"
+        { IMAGE_DIRECTORY_RESERVED,             ""                          }  // "Reserved"
+    };
+    //static const size_t max_directory_entry = LIBPE_SIZEOF_ARRAY(names);
+#endif
+
+    const IMAGE_DATA_DIRECTORY * const resourceDirectory = pe_directory_by_entry(ctx, IMAGE_DIRECTORY_ENTRY_RESOURCE);
+    if (resourceDirectory == NULL || resourceDirectory->Size == 0)
+        return NULL;
+
+    uint64_t resourceDirOffset = pe_rva2ofs(ctx, resourceDirectory->VirtualAddress);
+    /*char s[MAX_MSG];
+
+    if (resourceDirectory->Size != 0) {
+        snprintf(s, MAX_MSG, "%#x (%d bytes)",
+                resourceDirectory->VirtualAddress,
+                resourceDirectory->Size);
+
+#ifdef LIBPE_ENABLE_OUTPUT_COMPAT_WITH_V06
+        output(directory_names[IMAGE_DIRECTORY_ENTRY_RESOURCE], s); // Resource table
+#else
+        output(pe_directory_name(IMAGE_DIRECTORY_ENTRY_RESOURCE), s); // Resource table
+#endif
+        //printf("Offset by RVA: 0x%x\n\n", resourceDirOffset);
+    }*/
+
+    uintptr_t offset = resourceDirOffset;
+    void *ptr = LIBPE_PTR_ADD(ctx->map_addr, offset);
+    if (!pe_can_read(ctx, ptr, sizeof(IMAGE_RESOURCE_DIRECTORY))) {
+        // TODO: Should we report something?
+        return NULL;
+    }
+
+    NODE_PERES *node = malloc(sizeof(NODE_PERES));
+    node->lastNode = NULL; // root
+    node->rootNode = NULL; // root
+    node->nodeType = RDT_RESOURCE_DIRECTORY;
+    node->nodeLevel = RDT_LEVEL1;
+    node->resource.resourceDirectory = ptr;
+    //showNode(node);
+
+    for (int i = 1, offsetDirectory1 = 0; i <= (lastNodeByTypeAndLevel(node, RDT_RESOURCE_DIRECTORY, RDT_LEVEL1)->resource.resourceDirectory->NumberOfNamedEntries +
+                                                lastNodeByTypeAndLevel(node, RDT_RESOURCE_DIRECTORY, RDT_LEVEL1)->resource.resourceDirectory->NumberOfIdEntries); i++)
+    {
+        offsetDirectory1 += (i == 1) ? 16 : 8;
+        offset = resourceDirOffset + offsetDirectory1;
+        ptr = LIBPE_PTR_ADD(ctx->map_addr, offset);
+        if (!pe_can_read(ctx, ptr, sizeof(IMAGE_RESOURCE_DIRECTORY_ENTRY))) {
+            // TODO: Should we report something?
+            goto _error;
+        }
+
+        node = createNode(node, RDT_DIRECTORY_ENTRY);
+        NODE_PERES *rootNode = node;
+        node->rootNode = rootNode;
+        node->nodeLevel = RDT_LEVEL1;
+        node->resource.directoryEntry = ptr;
+        //showNode(node);
+
+        if (node->resource.directoryEntry->DirectoryName.name.NameIsString == 1){
+            offset = resourceDirOffset + node->resource.directoryEntry->DirectoryName.name.NameOffset;
+            ptr = LIBPE_PTR_ADD(ctx->map_addr, offset);
+            if (!pe_can_read(ctx, ptr, sizeof(IMAGE_RESOURCE_DATA_STRING))) {
+                // TODO: Should we report something?
+                goto _error;
+            }
+            node = createNode(node, RDT_DATA_STRING);
+            node->rootNode = rootNode;
+            node->nodeLevel = RDT_LEVEL1;
+            node->resource.dataString = ptr;
+            //showNode(node);
+        }
+
+        const NODE_PERES * lastDirectoryEntryNodeAtLevel1 = lastNodeByTypeAndLevel(node, RDT_DIRECTORY_ENTRY, RDT_LEVEL1);
+
+        if (lastDirectoryEntryNodeAtLevel1->resource.directoryEntry->DirectoryData.data.DataIsDirectory)
+        {
+            offset = resourceDirOffset + lastDirectoryEntryNodeAtLevel1->resource.directoryEntry->DirectoryData.data.OffsetToDirectory;
+            ptr = LIBPE_PTR_ADD(ctx->map_addr, offset);
+            if (!pe_can_read(ctx, ptr, sizeof(IMAGE_RESOURCE_DIRECTORY))) {
+                // TODO: Should we report something?
+                goto _error;
+            }
+
+            node = createNode(node, RDT_RESOURCE_DIRECTORY);
+            node->rootNode = (NODE_PERES *)lastDirectoryEntryNodeAtLevel1;
+            node->nodeLevel = RDT_LEVEL2;
+            node->resource.resourceDirectory = ptr;
+            //showNode(node);
+
+            for (int j = 1, offsetDirectory2 = 0; j <= (lastNodeByTypeAndLevel(node, RDT_RESOURCE_DIRECTORY, RDT_LEVEL2)->resource.resourceDirectory->NumberOfNamedEntries +
+                    lastNodeByTypeAndLevel(node, RDT_RESOURCE_DIRECTORY, RDT_LEVEL2)->resource.resourceDirectory->NumberOfIdEntries); j++)
+            {
+                offsetDirectory2 += (j == 1) ? 16 : 8;
+                offset = resourceDirOffset + lastNodeByTypeAndLevel(node, RDT_DIRECTORY_ENTRY, RDT_LEVEL1)->resource.directoryEntry->DirectoryData.data.OffsetToDirectory + offsetDirectory2;
+                ptr = LIBPE_PTR_ADD(ctx->map_addr, offset);
+                if (!pe_can_read(ctx, ptr, sizeof(IMAGE_RESOURCE_DIRECTORY_ENTRY))) {
+                    // TODO: Should we report something?
+                    goto _error;
+                }
+
+                node = createNode(node, RDT_DIRECTORY_ENTRY);
+                node->rootNode = rootNode;
+                node->nodeLevel = RDT_LEVEL2;
+                node->resource.directoryEntry = ptr;
+                //showNode(node);
+
+                if (node->resource.directoryEntry->DirectoryName.name.NameIsString == 1){
+                    offset = resourceDirOffset + node->resource.directoryEntry->DirectoryName.name.NameOffset;
+                    ptr = LIBPE_PTR_ADD(ctx->map_addr, offset);
+                    if (!pe_can_read(ctx, ptr, sizeof(IMAGE_RESOURCE_DATA_STRING))) {
+                        // TODO: Should we report something?
+                        goto _error;
+                    }
+                    node = createNode(node, RDT_DATA_STRING);
+                    node->rootNode = rootNode;
+                    node->nodeLevel = RDT_LEVEL2;
+                    node->resource.dataString = ptr;
+                    //showNode(node);
+                }
+
+                const NODE_PERES * lastDirectoryEntryNodeAtLevel2 = lastNodeByTypeAndLevel(node, RDT_DIRECTORY_ENTRY, RDT_LEVEL2);
+                offset = resourceDirOffset + lastDirectoryEntryNodeAtLevel2->resource.directoryEntry->DirectoryData.data.OffsetToDirectory;
+
+                ptr = LIBPE_PTR_ADD(ctx->map_addr, offset);
+                if (!pe_can_read(ctx, ptr, sizeof(IMAGE_RESOURCE_DIRECTORY))) {
+                    // TODO: Should we report something?
+                    goto _error;
+                }
+
+                node = createNode(node, RDT_RESOURCE_DIRECTORY);
+                node->rootNode = rootNode;
+                node->nodeLevel = RDT_LEVEL3;
+                node->resource.resourceDirectory = ptr;
+                //showNode(node);
+
+                offset += sizeof(IMAGE_RESOURCE_DIRECTORY);
+
+                for (int y = 1; y <= (lastNodeByTypeAndLevel(node, RDT_RESOURCE_DIRECTORY, RDT_LEVEL3)->resource.resourceDirectory->NumberOfNamedEntries +
+                                    lastNodeByTypeAndLevel(node, RDT_RESOURCE_DIRECTORY, RDT_LEVEL3)->resource.resourceDirectory->NumberOfIdEntries); y++)
+                {
+                    ptr = LIBPE_PTR_ADD(ctx->map_addr, offset);
+                    if (!pe_can_read(ctx, ptr, sizeof(IMAGE_RESOURCE_DIRECTORY_ENTRY))) {
+                        // TODO: Should we report something?
+                        goto _error;
+                    }
+                    node = createNode(node, RDT_DIRECTORY_ENTRY);
+                    node->rootNode = rootNode;
+                    node->nodeLevel = RDT_LEVEL3;
+                    node->resource.directoryEntry = ptr;
+                    //showNode(node);
+
+                    if (node->resource.directoryEntry->DirectoryName.name.NameIsString == 1){
+                        offset = resourceDirOffset + node->resource.directoryEntry->DirectoryName.name.NameOffset;
+                        ptr = LIBPE_PTR_ADD(ctx->map_addr, offset);
+                        if (!pe_can_read(ctx, ptr, sizeof(IMAGE_RESOURCE_DATA_STRING))) {
+                            // TODO: Should we report something?
+                            goto _error;
+                        }
+                        node = createNode(node, RDT_DATA_STRING);
+                        node->rootNode = rootNode;
+                        node->nodeLevel = RDT_LEVEL3;
+                        node->resource.dataString = ptr;
+                        //showNode(node);
+                    }
+
+                    const NODE_PERES * lastDirectoryEntryNodeAtLevel3 = lastNodeByTypeAndLevel(node, RDT_DIRECTORY_ENTRY, RDT_LEVEL3);
+                    offset = resourceDirOffset + lastDirectoryEntryNodeAtLevel3->resource.directoryEntry->DirectoryData.data.OffsetToDirectory;
+                    ptr = LIBPE_PTR_ADD(ctx->map_addr, offset);
+                    if (!pe_can_read(ctx, ptr, sizeof(IMAGE_RESOURCE_DATA_ENTRY))) {
+                        // TODO: Should we report something?
+                        goto _error;
+                    }
+                    node = createNode(node, RDT_DATA_ENTRY);
+                    node->rootNode = rootNode;
+                    node->nodeLevel = RDT_LEVEL3;
+                    node->resource.dataEntry = ptr;
+                    //showNode(node);
+
+                    offset += sizeof(IMAGE_RESOURCE_DATA_ENTRY);
+                }
+            }
+        }
+    }
+
+    return node;
+
+_error:
+    if (node != NULL)
+        freeNodes(node);
+    return NULL;
+}
+
+void __attribute__ ((constructor)) initLibrary(void) {
+ //
+ // Function that is called when the library is loaded
+ //
+   // printf("Library is initialized\n");
+
+}
+void __attribute__ ((destructor)) cleanUpLibrary(void) {
+ //
+ // Function that is called when the library is »closed«.
+ //
+  //  printf("Library is exited\n");
+}
+int get_ver(const char* path,char* res)
+{
+    if (path ==NULL||res==NULL)
+    {
+        return EXIT_FAILURE;
+    }
+    pe_ctx_t ctx;
+
+    pe_err_e err = pe_load_file(&ctx, path);
+    if (err != LIBPE_E_OK) {
+        pe_error_print(stderr, err);
+        return EXIT_FAILURE;
+    }
+
+    err = pe_parse(&ctx);
+    if (err != LIBPE_E_OK) {
+        pe_error_print(stderr, err);
+        return EXIT_FAILURE;
+    }
+
+    if (!pe_is_pe(&ctx))
+        EXIT_ERROR("not a valid PE file");
+
+   // output_open_document();
+
+    NODE_PERES *node = discoveryNodesPeres(&ctx);
+    if (node == NULL) {
+        fprintf(stderr, "this file has no resources\n");
+        return EXIT_SUCCESS;
+    }
+            getVersion(&ctx, node,res);
+
+  //  output_close_document();
+
+    freeNodes(node);
+
+    // free
+    err = pe_unload(&ctx);
+    if (err != LIBPE_E_OK) {
+        pe_error_print(stderr, err);
+        return EXIT_FAILURE;
+    }
+
+//    PEV_FINALIZE(&config);
+
+    return EXIT_SUCCESS;
+}
